# -*- coding: utf-8 -*-
"""玉川夏生_データマイニング最終課題.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uxoKcy1PuWIXqMofLPId6XKnH-NB7cf0
"""

# colabratory上でgoogle driveとマウント
from google.colab import drive
drive.mount('/content/drive')

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from networkx.algorithms.community import kernighan_lin_bisection

G = nx.Graph()
G = nx.read_weighted_edgelist('/content/drive/MyDrive/授業用/データマイニング/01.txt', nodetype=int)

nx.draw(G, node_size=400, with_labels=True, font_weight='bold')
plt.show()

print(G.degree())
print(nx.degree_histogram(G))

#次数分布
plt.bar(range(14),height=nx.degree_histogram(G))

#平均経路長
nx.average_shortest_path_length(G)

#直径
nx.diameter(G)

#係数
nx.average_clustering(G)

#次数相関
nx.degree_pearson_correlation_coefficient(G)

degree_centralities = list(nx.degree_centrality(G).values())
eigenvector_centralities = list(nx.eigenvector_centrality(G).values())
pagerank = list(nx.pagerank(G).values())
betweenness_centralities = list(nx.betweenness_centrality(G).values())
closeness_centralities = list(nx.closeness_centrality(G).values())

max_value = max(degree_centralities)
max_index = degree_centralities.index(max_value)
print(max_index)

max_value = max(eigenvector_centralities)
max_index = eigenvector_centralities.index(max_value)
print(max_index)

max_value = max(pagerank)
max_index = pagerank.index(max_value)
print(max_index)

max_value = max(betweenness_centralities)
max_index = betweenness_centralities.index(max_value)
print(max_index)

max_value = max(closeness_centralities)
max_index = closeness_centralities.index(max_value)
print(max_index)

pos = nx.spring_layout(G)

G.nodes()

nx.number_of_nodes(G)

from networkx.algorithms.community import label_propagation_communities
len(label_propagation_communities(G))

colors = ['red', 'blue']

lst_l = label_propagation_communities(G)
color_map_l = ['black'] * nx.number_of_nodes(G)
nodename=list(G.nodes())
counter = 0

for c in lst_l :
  for n in c :
    color_map_l[n-1] = colors[counter]
  counter = counter + 1

nx.draw_networkx_edges(G, pos)
nx.draw_networkx_nodes(G, pos, node_color=color_map_l)
nx.draw_networkx_labels(G, pos)
plt.axis('off')
plt.show()

from networkx.algorithms.community import naive_greedy_modularity_communities
len(naive_greedy_modularity_communities(G))

colors = ['red', 'blue', 'Green']

lst_m = naive_greedy_modularity_communities(G)
color_map_m = ['black'] * nx.number_of_nodes(G)
counter = 0
for c in lst_m :
  for n in c :
    color_map_m[n-1] = colors[counter]
  counter = counter + 1

nx.draw_networkx_edges(G, pos)
nx.draw_networkx_nodes(G, pos, node_color=color_map_m)
nx.draw_networkx_labels(G, pos)
plt.axis('off')
plt.show()

colors = ['red', 'blue']
pos = nx.spring_layout(G)

init_nodes = np.array_split(G.nodes(), 2)
init_partition = [set(init_nodes[0]), set(init_nodes[1])]

nodename=list(G.nodes())

lst_b = kernighan_lin_bisection(G, partition=init_partition)
color_map_b = ['black'] * nx.number_of_nodes(G)
counter = 0
for c in lst_b :
  for n in c :
    color_map_b[n-1] = colors[counter]
  counter = counter + 1

nx.draw_networkx_edges(G, pos)
nx.draw_networkx_nodes(G, pos, node_color=color_map_b)
nx.draw_networkx_labels(G, pos)
plt.axis('off')
plt.show()